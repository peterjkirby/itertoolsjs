<!DOCTYPE html>
<html>

<head>
<meta charset='utf-8' />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta name="description" content="Itertoolsjs : ItertoolsJs" />

<link rel="stylesheet" type="text/css" media="screen"
	href="stylesheets/stylesheet.css">

<title>Itertoolsjs</title>
</head>

<body>

	<!-- HEADER -->
	<div id="header_wrap" class="outer">
		<header class="inner">
			<a id="forkme_banner"
				href="https://github.com/peterjkirby/itertoolsjs">View on GitHub</a>

			<h1 id="project_title">ItertoolsJS</h1>

			<section id="downloads">
				<a class="zip_download_link"
					href="https://github.com/peterjkirby/itertoolsjs/zipball/master">Download
					this project as a .zip file</a> <a class="tar_download_link"
					href="https://github.com/peterjkirby/itertoolsjs/tarball/master">Download
					this project as a tar.gz file</a>
			</section>
		</header>
	</div>

	<!-- MAIN CONTENT -->
	<div id="main_content_wrap" class="outer">
		<section id="main_content" class="inner">

			<p>ItertoolsJS is inspired by the python Itertools library at
				http://docs.python.org/2/library/itertools.html</p>
			<p>I am in the process of optimizing and adding more
				functionality.</p>
			<p>The majority of the documentation at this time is an exact
				replica of the python Itertools documentation.</p>
			<p>I will correct the documentation once I have finished the
				ItertoolsJS library</p>

			<p>
				Feel free to check out my website at <a href="http://peterkirby.me">http://www.peterkirby.me</a>
			</p>


			<p>The following module functions all construct and return
				iterators. Some provide streams of infinite length, so they should
				only be accessed by functions or loops that truncate the stream.</p>

			<h2>itertools.chain(iterables)</h2>
			<p>Make an iterator that returns elements from the first iterable
				until it is exhausted, then proceeds to the next iterable, until all
				of the iterables are exhausted. Used for treating consecutive
				sequences as a single sequence. `iterables` should be an array of
				iterables.</p>

			<pre>
				<code>
chain: function(iterables){
	var items = [];	
    for (var i in iterables){
    	for(var item in iterables[i]){
	    	items.push(iterables[i][item]);
    	}
	}		
	return new Iterator(items);
}
	</code>
</pre>

			<h2>itertools.combinations(iterable, r)</h2>
			<p>Return r length subsequences of elements from the input
				iterable.</p>

			<p>Combinations are emitted in lexicographic sort order. So, if
				the input iterable is sorted, the combination will be produced in
				sorted order.</p>

			<p>Elements are treated as unique based on their position, not on
				their value. So if the input elements are unique, there will be no
				repeat values in each combination.</p>

			<pre>
				<code>
combinations: function(iterable, r){
	
	var iterator = new Iterator(iterable),
		results = [],
		k = 1;
	
	iterator.each(function(item, i){
		for (var j = k; j <= iterator.length-r+1; j++){
			results.push(item+iterator.splice(j, r-1));
		}
		k++;
	}, this);
	
	return results;		
},
</code>
			</pre>


			<h2>itertools.count([start, step])</h2>

			<p>Make an iterator that returns evenly spaced values starting
				with n. Often used as an argument to imap() to generate consecutive
				data points. Also, used with izip() to add sequence numbers.</p>

			<pre>
				<code>
count: function(start, step){
	if (typeof start === 'undefined')
		start = 0;
	
	if (typeof step === 'undefined')
		step = 1;
	
	var iterator = new Iterator();
	iterator.items = start;
	
	iterator.next = function(){
		var rtnNum = this.items; // do I really want to place a counter
									// here?
		this.items += step;
		return rtnNum;
	};
	
	return iterator;		
},

</code>
			</pre>


			<h2>itertools.cycle(iterable)</h2>

			<p>Make an iterator returning elements from the iterable and
				saving a copy of each. When the iterable is exhausted, return
				elements from the saved copy. Repeats indefinitely.</p>

			<pre>
				<code>
cycle: function(iterable){
	var iterator = new Iterator(iterable, true);
	
	iterator.next = function(){
		if(this.index+1 >= this.items.length){
			this.reset();
		}
		
		return this.items[++this.index];
	};
	
	return iterator;
},
</code>
			</pre>

			<p>Note, this member of the toolkit may require significant
				auxiliary storage (depending on the length of the iterable).</p>

			<h2>itertools.dropWhile(predicate, iterable)</h2>

			<p>Make an iterator that drops elements from the iterable as long
				as the predicate is true; afterwards, returns every element. Note,
				the iterator does not produce any output until the predicate first
				becomes false, so it may have a lengthy start-up time.</p>

			<pre>
				<code>
dropWhile: function(predicate, iterable){
	//@TODO
},
</code>
			</pre>


			<h2>itertools.groupBy(iterable[, key])</h2>

			<p>Make an iterator that returns consecutive keys and groups from
				the iterable. The key is a function computing a key value for each
				element. If not specified or is None, key defaults to an identity
				function and returns the element unchanged. Generally, the iterable
				needs to already be sorted on the same key function.</p>

			<p>The operation of groupby() is similar to the uniq filter in
				Unix. It generates a break or new group every time the value of the
				key function changes (which is why it is usually necessary to have
				sorted the data using the same key function). That behavior differs
				from SQL’s GROUP BY which aggregates common elements regardless of
				their input order.</p>

			<p>The returned group is itself an iterator that shares the
				underlying iterable with groupby(). Because the source is shared,
				when the groupby() object is advanced, the previous group is no
				longer visible. So, if that data is needed later, it should be
				stored as a list.</p>

			<pre>
				<code>
	groupBy: function(){
		//@TODO
	},	
</code>
			</pre>


			<h2>itertools.iFilter(predicate, iterable)</h2>

			<p>Make an iterator that filters elements from iterable returning
				only those for which the predicate is True. If predicate is None,
				return the items that are true.</p>

			<pre>
				<code>
iFilter: function(predicate, iterable){
	if (typeof predicate === 'undefined')
		predicate = function(x){return Boolean(x)};
	
	var iterator = new Iterator(iterable);
	
	iterator.next =  function(){
					
		if(this.index+1 >= this.items.length)
			return undefined;
		
		var next_item;
		
		while(this.index+1 < this.items.length){
			next_item = this.items[++this.index];
			if (predicate(next_item)){
				return next_item;
			}
		}
		
		return undefined;
	};
	
	return iterator;
},
</code>
			</pre>

			<h2>itertools.iFilterFalse(predicate, iterable)</h2>

			<p>Make an iterator that filters elements from iterable returning
				only those for which the predicate is False. If predicate is None,
				return the items that are false.</p>

			<pre>
				<code>
iFilterFalse: function(){
	//@TODO
},
</code>
			</pre>


			<h2>itertools.iMap(function, *iterables)</h2>

			<p>Make an iterator that computes the function using arguments
				from each of the iterables. If function is set to None, then imap()
				returns the arguments as a tuple. Like map() but stops when the
				shortest iterable is exhausted instead of filling in None for
				shorter iterables.</p>

			<p>The reason for the difference is that infinite iterator
				arguments are typically an error for map() (because the output is
				fully evaluated) but represent a common and useful way of supplying
				arguments to imap().</p>

			<pre>
				<code>
iMap: function(){
	//@TODO
},	
</code>
			</pre>


			<h2>
				itertools.iSlice(iterable, stop)<br /> itertools.iSlice(iterable,
				start, stop[, step])
			</h2>

			<p>Make an iterator that returns selected elements from the
				iterable. If start is non-zero, then elements from the iterable are
				skipped until start is reached. Afterward, elements are returned
				consecutively unless step is set higher than one which results in
				items being skipped. If stop is None, then iteration continues until
				the iterator is exhausted, if at all; otherwise, it stops at the
				specified position. Unlike regular slicing, islice() does not
				support negative values for start, stop, or step. Can be used to
				extract related fields from data where the internal structure has
				been flattened (for example, a multi-line report may list a name
				field on every third line).</p>

			<pre>
				<code>
iSlice: function(iterable, start_or_stop, stop, step){
	if (typeof step === 'undefined')
		step = 1;
	
	if (typeof start_or_stop === 'undefined' || start_or_stop === null)
		start_or_stop = -1;
	
	var iterator = new Iterator(iterable);
	
	if(typeof stop === 'undefined'){
		stop = start_or_stop;
		
		iterator.next = function(){
			if (this.index+1 >= this.items.length || this.index+1 >= stop)
				return undefined;
			
			return this.items[++this.index];
			
		}
	} else if (stop === null){
		iterator.index = start_or_stop-step;
		iterator.next = function(){
			if(this.index+1 >= this.items.length)
				return undefined;		
			
			this.index += step
			return this.items[this.index];
		};	
	} else {
		iterator.index = start_or_stop-step;
		iterator.next = function(){
			if (this.index+1 >= this.items.length || this.index+1 >= stop)
				return undefined;
				
			this.index += step;
			return this.items[this.index];
		};
	}
	
	return iterator;
},


</code>
			</pre>

			<p>If start is None, then iteration starts at zero. If step is
				None, then the step defaults to one.</p>

			<h2>itertools.iZip(iterables)</h2>


			<p>Make an iterator that aggregates elements from each of the
				iterables. Like zip() except that it returns an iterator instead of
				a list. Used for lock-step iteration over several iterables at a
				time.</p>

			<pre>
				<code>
iZip: function(){
	//@TODO
},
</code>
			</pre>

			<p>The left-to-right evaluation order of the iterables is
				guaranteed. This makes possible an idiom for clustering a data
				series into n-length groups using izip(*[iter(s)]*n).</p>

			<p>izip() should only be used with unequal length inputs when you
				don’t care about trailing, unmatched values from the longer
				iterables. If those values are important, use izip_longest()
				instead.</p>


			<h2>itertools.permutations(iterable)</h2>

			<p>Return successive r length permutations of elements in the
				iterable.</p>

			<p>If r is not specified or is None, then r defaults to the
				length of the iterable and all possible full-length permutations are
				generated.</p>

			<p>Permutations are emitted in lexicographic sort order. So, if
				the input iterable is sorted, the permutation tuples will be
				produced in sorted order.</p>

			<p>Elements are treated as unique based on their position, not on
				their value. So if the input elements are unique, there will be no
				repeat values in each permutation.</p>

			<pre>
				<code>
// This is an older piece of code... I'm reworking it now
permutations: function(sequence){
	var isNumber = false,
		n = 0,
		results = [];
	
	if (typeof sequence == 'number'){
		sequence = sequence.toString();
		isNumber = true;
	}
	
	try{
		n = sequence.length;		
	} catch (e){
		throw "sequence is not permuable";
	}
		
	if (n == 0 || n == 1)
		return [sequence];
	
	this._permute(sequence.split('').sort(), 0, results);	
	
	for (var perm in results){
		results[perm] = results[perm].join('');
		if (isNumber)
			results[perm] = parseFloat(results[perm]);				
	}
	
	return results;
},

_permute: function(sequence, level, outArr){

	var l = sequence.length;
	var c = null;
	
	if (l == level){
		outArr.push(this._copy(sequence));
		return
	}
		
	for (var i = level; i < sequence.length; i++){
		if (c == sequence[i])
			continue;
		
		c = sequence[i];
		
		this.swap(level, i, sequence);
		this._permute(sequence, level+1, outArr);
	}
	for (var i = level; i < l-1; i++){
		sequence[i] = sequence[i+1];
	}
	sequence[l-1] = c;
},
</code>
			</pre>

			<h2>itertools.product(*iterables[, repeat])</h2>

			<p>Cartesian product of input iterables.</p>

			<p>Equivalent to nested for-loops in a generator expression. For
				example, product(A, B) returns the same as ((x,y) for x in A for y
				in B).</p>

			<p>The nested loops cycle like an odometer with the rightmost
				element advancing on every iteration. This pattern creates a
				lexicographic ordering so that if the input’s iterables are sorted,
				the product tuples are emitted in sorted order.</p>

			<p>To compute the product of an iterable with itself, specify the
				number of repetitions with the optional repeat keyword argument. For
				example, product(A, repeat=4) means the same as product(A, A, A, A).</p>

			<p>This function is equivalent to the following code, except that
				the actual implementation does not build up intermediate results in
				memory:</p>

			<pre>
				<code>
product: function(){
	//@TODO
},
</code>
			</pre>

			<h2>itertools.repeat(object[, times])</h2>

			<p>Make an iterator that returns object over and over again. Runs
				indefinitely unless the times argument is specified. Used as
				argument to imap() for invariant function parameters. Also used with
				izip() to create constant fields in a tuple record.</p>

			<pre>
				<code>
repeat: function(obj, times){
	if(typeof times === 'undefined')
		times = true;
	
	var iterator = new Iterator();
	// @TODO
	// Don't set items this way... Figure out better way to do this
	iterator.items = obj;
	if (times === true){
		iterator.next = function(){
			return this.items;
		}
		return iterator;
	}
	iterator.index = 0;
	
	iterator.next = function(){
		if (this.index >= times)
			return undefined;
		
		this.index++;
		return this.items;
	}
	
	return iterator;
},
</code>
			</pre>

			<p>A common use for repeat is to supply a stream of constant
				values to imap or zip:</p>


			<h2>itertools.starMap(function, iterable)</h2>

			<p>Make an iterator that computes the function using arguments
				obtained from the iterable. Used instead of imap() when argument
				parameters are already grouped in tuples from a single iterable (the
				data has been “pre-zipped”). The difference between imap() and
				starmap() parallels the distinction between function(a,b) and
				function(*c).</p>

			<pre>
				<code>
starMap: function(fn, iterable){
	
	var iterator = new Iterator(iterable);
	
	iterator.next = function(){
		if (this.index+1 >= this.items.length)
			return undefined;

		return fn.apply(this, this.items[++this.index]);
	};
	
	return iterator;
},
</code>
			</pre>


			<h2>itertools.takeWhile(predicate, iterable)</h2>

			<p>Make an iterator that returns elements from the iterable as
				long as the predicate is true.</p>

			<pre>
				<code>
takeWhile: function(predicate, iterable){
	
	var iterator = new Iterator(iterable);
	this.wasPredicateTrue = true; // starts true... probably not best to
									// do that
	
	iterator.next = function(){
		if (this.index+1 >= this.items.length && this.wasPredicateTrue)
			return undefined;
		
		var rtnVal = this.items[++this.index];
		
		if(predicate(rtnVal))
			return rtnVal;
		
		this.wasPredicateTrue = false;
	};
	
	return iterator;		
},
</code>
			</pre>


			<h2>itertools.tee(iterable[, n=2])</h2>
			<p>Return n independent iterators from a single iterable.</p>

			<pre>
				<code>
tee: function(iterable){
	//@TODO
},
</code>
			</pre>

			<p>Once tee() has made a split, the original iterable should not
				be used anywhere else; otherwise, the iterable could get advanced
				without the tee objects being informed.</p>

			<p>This itertool may require significant auxiliary storage
				(depending on how much temporary data needs to be stored). In
				general, if one iterator uses most or all of the data before another
				iterator starts, it is faster to use list() instead of tee().</p>

		</section>
	</div>

	<!-- FOOTER  -->
	<div id="footer_wrap" class="outer">
		<footer class="inner">
			<p class="copyright">
				Itertoolsjs maintained by <a href="https://github.com/peterjkirby">peterjkirby</a>
			</p>
			<p>
				Published with <a href="http://pages.github.com">GitHub Pages</a>
			</p>
			
			<nav class="socia-icons-wrapper">
			<ul class="social-icons">
			<li><a href="http://www.facebook.com/peterjkirby"><img src="/images/facebook.png" alt="facebook" /></a></li>
			<li><a href="http://www.twitter.com/peterjkirby"><img src="/images/twitter.png" alt="twitter" /></a></li>
			<li><a href="http://www.facebook.com/peterjkirby"><img src="/images/facebook.png" alt="facebook" /></a></li>
			</ul>
			</nav>
		</footer>
	</div>



</body>
</html>
